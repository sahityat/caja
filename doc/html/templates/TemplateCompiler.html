<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Template Compilers</title>
<style type="text/css">
/* indent everything but headers */
body { margin-left: .25in }
h1, h2, h3, h4, h5, h6 { margin-left: -.125in !important }
h1 { text-align: center; width: auto }

/* color headers */
h1, h2, h3 {
  background-color: #eef;
  padding: 0 0 0 6px;
  border: 2px solid #dde
}

/* misc */
dt { font-weight: bold }
code { white-space: nowrap }
div.meta { float: right }
table { vertical-align: top }
</style>
<script type="text/javascript"
 src="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.js"
></script>
<script type="text/javascript"
 src="http://google-code-prettify.googlecode.com/svn/trunk/src/lang-css.js"
></script>
<link rel="stylesheet" type="text/css"
 href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css"
>
</head>
<body onload="prettyPrint()" bgcolor="white">
<div class="meta">
<b>Status</b>: draft as of <span title="20090205">5 Feb, 2009</span><br>
<b>Author</b>: <cite>mikesamuel@gmail.com</cite>
</div>
<h1>Template Compilers</h1>

<h2>Background</h2>
<p><a href="http://code.google.com/p/google-caja/">Caja</a> provides a way to
sandbox javascript.  It uses a variety of mechanisms to limit the authority
scripts have running in a browser by partitioning a document into a multiple
virtual documents.

<p><a href="http://www.quirksmode.org/dom/innerhtml.html">Benchmarks</a> show
that creating a UI via <b>DOM manipulation is slow</b> even on modern browsers:
<blockquote>
  The most obvious conclusion of these tests is that innerHTML is
  faster than "real" W3C DOM methods in all browsers. The W3C DOM
  table methods are slow to very slow, especially in Explorer.
</blockquote>

<p>While there are a number of templating languages that run in-browser
(including browser built-ins like <a href="http://www.w3.org/Style/XSL/"
>XSL</a>, languages that compile to javascript like
<a href="http://code.google.com/p/gxp/wiki/WhyGxp">GXP</a>, javascript only
solutions like <a href="http://code.google.com/p/google-jstemplate/"
>JSTemplates</a>, and others), <b>there is no consensus on how to do templating
on the browser</b>.  The wide use of systems like FBML, YML, and OSML amongst
gadget authors show that templating languages are used.

<p>Many of these existing templating languages are widely tied to app-hosting
services (like Facebook and FBML) but there are a number of non-proprietary
in-browser templating languages.

<p>Some of these templating languages use sensible defaults to mitigate XSS and
other injection problems, but
<b>no template engine addresses malicious template authors</b>.

<h2>Goal</h2>
<p>A mechanism to allow HTML templating schemes like Soy, OpenSocial
Templates, client-side GXP, XSL, and others to <b>work with a Javascript
sandbox</b> like Caja without compromising the security
properties of the sandbox even against malicious developers.

<p>It is a goal to support a wide range of templating languages
including dynamic attribute values, dynamic textual content, conditional and
repeated evaluation, and decomposition of large templates into smaller ones.
Dynamic tag names, such as <code>&lt;h$number&gt;</code> is a nice-to-have.

<p>It is a goal for templates to <b>compile to efficient javascript</b>
functions.  Since there is a 10x-100x performance penalty for DOM manipulation
over parsing <code>innerHTML</code> it is a goal for templates to not incur
a performance penalty for the portions that can be statically verified safe
 &mdash; if a template contains a lot of boilerplate HTML with one dynamic
substitution then the performance of the template should approach the
performance of the browser's HTML parser as the amount of boilerplate
&rarr; &#8734;.

<p>It is a goal to support a variety of security policies, including
ones that limit which URLs can be linked to, that sandbox handler
scripts, that restrict navigation of the current window, etc.  It is
not a goal to prevent all quoting confusion, but it is a goal to
prevent injected code from invoking any function not explicitly
exported from a caja module for use by event handlers.

<p>It is not a goal to support arbitrary policies and we restrict
policies to those which can be specified in terms of whitelists of
elements, attributes, and regular grammar constraints on HTML
attributes and CSS properties.  Supporting
<a href="http://en.wikipedia.org/wiki/Trusted_path">trusted-path</a> is
nice-to-have but is not a goal.

<p>It is goal for a cajoled HTML page to be compilable to a zero-argument
template once interleaved script blocks have been removed in a way that
lets us track which portions need to be visible to each script block.

<p>It is a non-goal to support the exact semantics of languages like PHP that
are specified in terms of string interpolation.

<p>It is a non-goal to support those portions of templating languages that
self-evaluate (i.e. treat an input as a string of the template language),
or that allow expressions to introspect over a partially built output.


<h2>Glossary</h2>
<dl>
<dt><a href="http://en.wikipedia.org/wiki/AlphaRenaming">Alpha renaming</a></dt>
<dd>An operation that replaces all uses of an identifier corresponding to
the same memory slot with a name that is unique within a compilation unit.
After an alpha renaming, scope analysis is simple since no identifier masks
another identifier.
<dt>CSS Schema</dt>
<dd>Describes allowed values for CSS properties, and possibly normalizing
    transformations (e.g. quoting font names, or turning string URLs into
    the <code>url("...")</code> form).
<dt>Dynamics</dt>
<dd>Portions of an HTML document that cannot be verified statically.
<dt>Falsey</dt>
<dd>A javascript value <code>x</code> such that
    <code class="prettyprint">false === !!x</code>.
<dt>HTML Schema</dt>
<dd>Describes allowed elements and attributes, constraints on
    attribute values, and possibly containment relationships between
    elements.
<dt>HTML Template</dt>
<dd>A function from input values to strings of HTML usually specified via
    a language with some superficial similarity to HTML.
<dt>IHTML</dt>
<dd>A language defined in this document used as an intermediate representation
    of HTML templates.
    It is HTML plus a few custom elements which allow for (1) template definition
    and scoping, (2) calling of a defined template, (3) repetition and
    alternation, (4) specification of a dynamic portion in terms of
    javascript, and (5) text localization.
<dt><a href="http://en.wikipedia.org/wiki/Internationalization_and_localization">L10N</a></dt>
<dd>Text Localization is a mechanism by which appropriate passages of human
    language text are chosen based on a viewer's locale.
<dt><a href="http://en.wikipedia.org/wiki/Writing_direction#Directionality">RTL Script</a></dt>
<dd>Right-To-Left, e.g. the Arabic, Hebrew, and Perso-Arabic scripts.
<dt>Safe identifier</dt>
<dd>A valid javascript identifier in unicode normal form C that does not
    end in <code>__</code> and that does not contain any format control
    characters, and that is not the unreserved-keyword <code>arguments</code>.
<dt>Sanitizer</dt>
<dd>A transformation from code from an untrusted source to code in the same
    language with well-understood security properties.
    Often involves checking, rewriting, and normalizing a parse tree.
<dt>TCB</dt>
<dd>Trusted Computing Base.  The portion of code that must be correct for
    the design to preserve the security properties that it purports to.
<dt>Template Translator</dt>
<dd>A program that converts a template in an HTML templating language into IHTML.
<dt>((Trademark))</dt>
<dd>An unforgeable marker attached to an object which asserts that the
    object has certain security properties.  This can be viewed either
    as memoizing the fact that the object has passed some validation,
    or that the object has been
    <a href="http://en.wikipedia.org/wiki/Trademark_computer_security"
     >trademarked</a> by some code that is explicitly trusted by code that
    checks the trademark.
<dt>Truthy</dt>
<dd>A javascript value x where <code class="prettyprint">true === !!x</code>.
</dl>

<h2>Notational Conventions</h2>
<img src="NotationalConventions.png" alt="Notational conventions">

<h2>Overview</h2>
<img src="TemplateCompiler.png" alt="Pipeline"
 style="float: left; margin-left: -3px; margin-right: 3px">
((TODO: Replace template system with template translator in diagram))
<p>We first define an intermediate language, IHTML, that a template
can be compiled to.  Template language designers can implement a
translator which performs this conversion, and the security of the
system does not depend on any aspect of this conversion, so the author
of the template language does not need to be a security expert.
<pre class="prettyprint"
>&lt;template name="helloPlanets"&gt;
  <b>&lt;ul&gt;</b>
    &lt;for-each name="planet" in="planets"&gt;
      <b>&lt;li&gt;</b>
        <b>Hello </b>$planet
      <b>&lt;/li&gt;</b>
    &lt;/for-each&gt;
  <b>&lt;/ul&gt;</b>
&lt;/template&gt;</pre>
might compile to
<pre class="prettyprint">
&lt;ihtml:template name="helloPlanets" formals="planets"&gt;
  <b>&lt;ul&gt;</b>
    &lt;ihtml:do vars="i n" init="i = 0, n = planets.length"
     while="++i &lt; n"&gt;
      &lt;ihtml:template name="loopbody0" formals="planet"&gt;
        <b>&lt;li&gt;</b>
          <b>Hello </b>&lt;ihtml:dynamic expr="planet"/&gt;
        <b>&lt;/li&gt;</b>
      &lt;/ihtml:template&gt;
      &lt;ihtml:call ihtml:template="loopbody0" planet="planets[i]"/&gt;
    &lt;/ihtml:do&gt;
  <b>&lt;/ul&gt;</b>
&lt;ihtml:template&gt;</pre>

<p>The template compiler then applies
<a href="http://code.google.com/p/google-caja/wiki/CajaWhitelists">HTML and CSS
schemas</a> to the IHTML parse tree.  The schemas may add/remove/normalize HTML
elements, HTML attributes, and CSS properties.  IHTML nodes are ignored entirely
by the schemas, so that once schemas have been successfully applied the
non-IHTML portion is known to be a safe quantity.

<p>IHTML nodes contain javascript which is run through a
<a href="http://code.google.com/p/google-caja/">Javascript sandboxer</a>
which will complain if any expressions have unexpected free variables, and
may add runtime checks.  This same sandboxer is used with static HTML to
sanitize <code>onclick</code> attributes, etc.

<p>Once validation is done, the IHTML&rarr;JS compiler converts the IHTML tree
to a javascript function.  This stage may be implemented in a number of ways:
<ul>
<li>Composing a string from parts as outlined under detailed design.</li>
<li>Using <code>innerHTML</code> to parse the static bit, duplicating
    repeated sections, and walking the tree to inject dynamic bits at the
    right place.
</ul>
but they all have to vet dynamic values.  For each dynamic bit they have to
apply a policy:
<ul>
<li>For dynamic element names, they have to whitelist the name, and check
    whether it can appear in its parent.
<li>For dynamic attribute values, they have to check the client-side
    schema against the (element name, attribute name) pair, and possibly
    rewrite or reject the value.
<li>For dynamic text, they need to check that the containing tag is
    allowed to contain dynamic text, and possibly choose the right
    (PCDATA vs RCDATA vs CDATA) escaping convention.
</ul>

<p>The compiled function is now ready to be shipped to the client.  It
takes values of a form specified by the template compiler, so this scheme
is agnostic as to whether templates take a javascript value as input, an
XML document, or a channel to remote content as input.
The return convention is independent of the templating language.
Possible return conventions include:
<ul>
<li>return a value that is trademarked as known safe HTML which
    can be injected into any element that accepts PCDATA content.
<li>as 1, but attach DHTML behaviors extracted from <code>script</code>
    elements in the input as promises to be executed when the output
    is actually attached to the live DOM.
<li>output an object that encapsulates both the string of static HTML, and
    a set of dynamics : descriptions of how to find nodes, which dynamic
    part to specify, and the appropriate sanitizer.
    This return convention would allow us to represent a gadget as
    a zero-argument template, and could be wrapped to simply implement
    return convention (1) or (2).
<li>as another approach but continuation passing style.
</ul>

<p>There are a variety of ways applications could display a template output
created by untrusted code, but one way is to provide a privileged channel
that checks the trademark on its input, and if it passes, injects it into
a DOM node.  DOMita virtualizes <code>HTMLElement.innerHTML</code> this way.


<h2>Detailed Design</h2>

<h3>IHTML</h3>
<p>IHTML is an abstract template language that real template languages can be
compiled to.  It has very few constructs so is easy to reason about, but is
not meant to be written by humans.

<p>Although all dynamic content and control flow decisions are specified
as javascript expressions, templates can use any expression language
that can be translated to javascript.

<p>One of the properties that make it easy to reason about is that,
for each node, we have a very good bound on the set of node-types
contributed to the output by that node &mdash; an HTML element, text
node, or attribute contributes its type, an <code>ihtml:do</code>
element contributes the union of its body and its alternative and a
template call contributes the union of the elements in the template
body.  Since all template calls are dispatched statically, we can
preserve containment relationships specified in the HTML schema.

<p>IHTML adds seven elements to HTML that can appear anywhere
<a href="http://www.w3.org/TR/REC-html40/sgml/dtd.html#special"
>HTML special elements</a> can appear.  Though there are restrictions on which
IHTML elements can contain others.

<h4>Template definition : <code>ihtml:template</code></h4>
<pre class="prettyprint">
&lt;ihtml:template name="foo" formals="bar,baz"&gt;
  &lt;p&gt;Body that uses bar and baz&lt;/p&gt;
&lt;/ihtml:template&gt;
</pre>

<p>Defines a template and its signature.  The top level element in an
IHTML doc produced by a template compiler must by of this type.</p>
<p>The required <code>name</code> attribute is a safe identifier.
<p>The required <code>formals</code> attribute is a comma separated list of
distinct safe identifiers.  An identifier may not be both a name and a formal
for the same <code>ihtml:template</code>.

<p>An <code>ihtml:template</code> is said to be <a id="reentrant">reentrant</a>
iff it is on a loop in a graph with a node for each template in the compilation
unit and an edge for each <code>ihtml:call</code> from the closest containing
<code>ihtml:template</code> to the called template.  This graph has to be
computed post <a href="#alpha-renaming">alpha renaming</a>.

<p>Template definitions can appear at the top level or as children of other
templates.

<h4>Template invocation : <code>ihtml:call</code></h4>
<pre class="prettyprint">
&lt;ihtml:call ihtml:template="foo" bar="1" baz="2"/&gt;
</pre>
<p>Invokes a template substituting the DOM produced by the template at
the call site.  A template that is declared inside another template is
assumed to inherit all the state of the outer template.  Inner
templates are not first-class so there is no danger of a template
being called after the scope in which it's declared has been left.
<p>The required <code>ihtml:template</code> attribute is a safe identifier and
specifies the template to call.  If it is the name of an inner template
then that one is used.  Otherwise, it must be the name of a top-level
template in the same compilation unit.
<p>All other attributes are javascript expressions that are mapped to
identifiers in the called template's <code>formals</code> list.
The set of actual attributes in the <code>ihtml:call</code> must match
the set of formals in the called template.
<p>Calls can appear anywhere a text node, HTML element,
<code>ihtml:attribute</code>, or <code>ihtml:element</code>
could appear, though it is an error for a call that might produce
elements to appear inside an <code>ihtml:attribute</code>
or <code>ihtml:element</code> element.

<h4>Block scoping, repetition and conditional evaluation
 : <code>ihtml:do</code> and <code>ihtml:else</code></h4>
<pre class="prettyprint">
&lt;ihtml:do
 vars="aLocalVariableName,another"
 init="aBooleanExpression()"
 while="aBooleanExpression()"&gt;
  &lt;p&gt;Evaluated until the while attribute evaluates to falsey.&lt;/p&gt;
&lt;ihtml:else/&gt;
  &lt;p&gt;Evaluated once if init is initially falsey.&lt;/p&gt;
&lt;/ihtml:do&gt;
</pre>

<p>Introduces a scoping block, and possibly repeatedly evaluates its body.
<p>The optional <code>vars</code> attribute specifies a set of variables
that enter scope when the <code>ihtml:do</code> is entered, and which
are cleaned up when it is exited.
<p>The optional <code>init</code> attribute is a javascript expression
that is executed before control enters the <code>ihtml:do</code>'s body.
If the result is truthy then control passes to the <code>while</code> attribute,
otherwise control passes to the alternate as described below.
This can be used to initialize <code>vars</code> as in
<code class="prettyprint">a = 1, b = 2, true</code>.
<p>The optional <code>while</code> attribute is a javascript expression.
The body is evaluated as long as the <code>while</code> attribute's result is
truthy.
<p>The <code>ihtml:do</code> may contain a single <code>ihtml:else</code>
element.  If it does, its body is every child before the
<code>ihtml:else</code> and its alternate is every child after.
Otherwise the body is every child, and the alternate is the empty node list.
<p><code>ihtml:do</code>s can appear anywhere a text node, HTML element,
<code>ihtml:attribute</code> or <code>ihtml:element</code> can appear.

<h4>Element Names : <code>ihtml:element</code></h4>
<pre class="prettyprint">
&lt;h1&gt;
  <b>&lt;ihtml:element&gt;</b>H&lt;ihtml:dynamic expr="headerLevel"/&gt;<b>&lt;/ihtml:element&gt;</b>
  Header Text
&lt;/h1&gt;
</pre>

<p>Used in conjunction with <code>ihtml:dynamic</code> to specify a
replacement for the tag name of the containing HTML element.  Must be
a descendant of an HTML element.

<p>Contains textual content specifying the name of an element to use
in place of a containing HTML element.  The containing element must be
one that has a set of attribute definitions that have the same meaning
when applied to the replacement tag type, and must be able to appear
in similar circumstances.  E.g. if the containing element is
a <code>TBODY</code> then the textual content of the body of
the <code>ihtml:element</code> (after <code>ihtml:dynamic</code>
evaluation) could be any of <code>TBODY</code>, <code>TFOOT</code>,
or <code>THEAD</code> since all of those can appear in the same
position, can contain the same kinds of nodes, and have the same set
of attribute definitions.

<p>Can appear inside any HTML element, or as a child of either an
<code>ihtml:template</code> or <code>ihtml:do</code> element.</p>

<h4>Attribute Values : <code>ihtml:attribute</code></h4>
<pre class="prettyprint">
&lt;!-- A link with a dynamic URL --&gt;
&lt;a&gt;
  <b>&lt;ihtml:attribute name="href"&gt;</b>
    &lt;ihtml:dynamic expr="url"/&gt;
  <b>&lt;/ihtml:attribute&gt;</b>
  Link Text
&lt;/a&gt;
</pre>

<p>Used in conjunction with <code>ihtml:dynamic</code> and
<code>ihtml:message</code> to specify an attribute value.
<p>Must have a <code>name</code> attribute which must be a valid HTML
attribute name.  If the element is a descendant of
an <code>ihtml:template</code> then it's name attribute must be
allowed on the type of element from which the template is called.
Otherwise it must be allowed on the closest containing HTML element.

<p>SCRIPT attributes (e.g. <code>onclick</code>) attributes cannot be
added this way.

<p>If its content is a single <code>&lt;ihtml:dynamic&gt;</code>
element, and the attribute specified is a valueless attribute
(e.g. <code>checked</code> or <code>selected</code>) then the
expression will be treated as a boolean expression which specifies
whether or not the attribute is present on the output &mdash; any
truthy value will cause the attribute to be present, and any falsy
value will cause it to be absent.

<p>Can appear inside any HTML element, or as a child of either an
<code>ihtml:template</code> or <code>ihtml:do</code> element.</p>


<h4>Dynamic content : <code>ihtml:dynamic</code></h4>
<pre class="prettyprint">
&lt;!-- Dynamic text --&gt;
&lt;p&gt;My name is <b>&lt;ihtml:dynamic expr="name"/&gt;</b>.&lt;/p&gt;
</pre>
<p>Uses javascript to output dynamic text.  This can be used to
specify dynamic PCDATA text nodes, or if it appears inside
an <code>ihtml:element</code> or <code>ihtml:attribute</code>, then it
can be used to change an element name or attribute value.

<h4>Text Localization : <code>ihtml:message</code></h4>
<pre class="prettyprint">
&lt;ihtml:message name="result_index"
 description="The index of the current result in the result list"&gt;
  Result &lt;b&gt;&lt;ihtml:ph name="start"/&gt;&lt;ihtml:dynamic expr=" i + 1 "/&gt;&lt;ihtml:eph/&gt;&lt;/b&gt;
  of &lt;b&gt;&lt;ihtml:ph name="end"/&gt;&lt;ihtml:dynamic expr=" n "/&gt;&lt;ihtml:eph/&gt;&lt;/b&gt;
&lt;/ihtml:message&gt;
</pre>
Marks a passage of human readable text.  Cannot contain other
<code>ihtml:{message,def,do,call}</code> elements outside of a
<code>ihtml:ph</code>, <code>ihtml:eph</code> pair.

<p>This element must have a <code>name</code> attribute which is a safe
identifier and may contain matched pairs of <code>ihtml:ph</code> and
<code>ihtml:eph</code> elements, as shown above, which mark the beginning
and end of a named placeholder respectively.

<p>TODO: Is it the responsibility of the template compiler to ensure that
placeholders can be re-ordered without changing the semantics of the
template?
Or can this be automatically handled by allowing a template to be called
and its output captured in a temporary?</p>


<h4>Debugging Info in IHTML</h4>
<p>Template implementors should use a lexer&amp;|parser that preserves source
file position info, and copy that over to the IHTML tree so that the schema
can report locations of items that don't validate.  File positions must be
attached to every node -- even <code>ihtml:dynamic</code> since in debug
mode, dynamic sanitization failures will emit log messages to the browser
console.

<h3>I18N &amp; L10N</h3>
<p>This template scheme provides no explicit mechanism for
internationalization(<a href="#auto-rtl">*</a>),
though it does provide for text localization (L10N).  A templating language
that provides syntactic support for I18N concerns, like date and number
formatting, should use javascript libraries to provide formatting.

<p>Text localization is almost orthogonal to generic templating &mdash;
a template compiler could implement it's own message extraction and
substitution scheme, but app hosting services can help application authors by
automating parts of the message extraction and translation workflow.
A hosting service can run the template compiler stage by itself on a
template to produce a message bundle which can then be forwarded to
translators.  Text localization, though orthogonal, is one of the features
that if supported at the generic templating, will lower the cost for hosting
services to experiment with different templating schemes.

<p>Unlike server-side text-localization, on the browser, we only need to
deal with a single locale: that of the user.  So we take a message bundle,
and rewrite the IHTML document to function per-locale.
This is more efficient, since the client need not maintain mappings
per-locale, and need not do redundant lookups or string concatenations.
It is also more secure since we have the localized strings in context
before we attempt to do validation.

<p>A message bundle is a mapping from message IDs to strings with
placeholders like
<code>"Push &lt;button&gt;&lt;ihtml:ph name='button_text'/&gt;&lt;/button&gt; to
send mail to &lt;ihtml:ph name='recipient'/&gt;."</code>
where the content is HTML.

<p>The text localizer walks over the IHTML tree replacing
<code>ihtml:msg</code>, <code>ihtml:ph</code>, and
<code>ihtml:eph</code> elements with the appropriate message as in
<table summary="before and after text localization">
<tr valign="middle">
<td><pre class="prettyprint">
&lt;ihtml:message name="greeting"&gt;
  Hello
  &lt;ihtml:ph name="planet"/&gt;
    &lt;ihtml:dynamic expr="planet"/&gt;
  &lt;ihtml:eph/&gt;!
&lt;/ihtml:message&gt;
</pre></td>
<td>&rarr;</td>
<td>Greeting in English: <code>"Hello &lt;ihtml:ph name='planet'/&gt;!"</code>
<br>Greeting in Spanish: <code>"&#xA1;Hola &lt;ihtml:ph name='planet'/&gt;!"</code>
<br>Locale: es
<td>&rarr;</td>
<td><pre class="prettyprint lang-html">
&#xA1;Hola &lt;ihtml:dynamic expr="planet"/&gt;!
</pre></td>
</table>
by doing the following:
<ul>
  <li>Extract all placeholders (between
    <code class="prettyprint"
     >&lt;ihtml:ph name="&hellip;"/&gt;&hellip;&lt;ihtml:eph/&gt;</code>)
    into a map indexed by the <code>ihtml:ph</code>s' name attributes.
    If a name is reused, report an error.
    Placeholder content is represented as a sequence of HTML tokens.
  <li>Lookup the message matching the <code>ihtml:message</code>'s
    <code>name</code> attribute.
  <li>If the set of placeholder names in the <code>ihtml:message</code> is
    different from that in the message bundle message, report an error.
  <li>Generate a token sequence from the message bundle message with the token
    sequences for placeholders substituted with those extracted in step 1,
    and parse that token sequence to a document fragment.
  <li>Replace the <code>ihtml:message</code> element with the document
    fragment's children.
</ul>

<p>Templating languages that don't explicitly mark messages, or don't
explicitly name messages can make a best effort to identify message boundaries
and use string hashing to generate a message id.

<h3>CSS &amp; HTML Schemas</h3>
<p>CSS and HTML schemas are already applied to Cajoled gadgets, so this
document does not cover the details of either server or client-side schema
based validation.
<p>This design does rely on schema validation to produce an IHTML tree
that is valid, safe HTML if all inner <code>ihtml:template</code>
elements were removed, all <code>ihtml:call</code> were replaced with
their templates content (or nothing if recursion would result), all
<code>ihtml:do</code> were replaced with either their body or
alternate, and all other <code>ihtml:</code> elements were replaced
with their children.

<h3>Javascript sandboxing</h3>
<p>Some of the custom <code>ihtml:</code> elements contain attributes that are
javascript expressions.
Sandboxing javascript in IHTML requires two steps &mdash; one to make sure
that the scoping of variables defined in <code>ihtml:do</code> and
<code>ihtml:template</code> are correct, and the second to sandbox those
expressions.

<p>The first step is to do an alpha-renaming to prevent namespace
collisions and preserve the block scoping properties of the
<code>ihtml:do</code> and <code>ihtml:template</code> constructs.
This alpha-renaming affects template names as well.
Template names are treated as in a distinct namespace from formal
parameters and locals.  For security we rely on the alpha-renaming to
not introduce unsafe-identifiers since it might mask the output
buffer, and the sanitizer functions.  We do not rely on the
alpha-renaming to be correct for security to hold.

<h4 id="alpha-renaming">Alpha-Renaming</h4>
<p>An alpha-renaming is a remapping of identifiers which ensures that
no use of an identifier in a scope masks a use of an identifier in an
outer scope.  We do an alpha-renaming because javascript is not a
block scoped language, but the <code>ihtml:template</code> and
<code>ihtml:do</code> constructs specify block scoping.

<p>After an alpha renaming it becomes trivial to inline <code>ihtml:call</code>s
which is important since we provide only one operation that can decompose
the input.

<p>We define a <code>NameContext</code> class,
<pre class="prettyprint">
final class NameContext {
  NameContext parent;
  Iterator&lt;String&gt; nameGenerator;
  // maps names in original source to
  Map&lt;String, VarInfo&gt; vars = new HashMap&lt;String;, VarInfo&gt;;

  static final class VarInfo {
    final String newName;
    final FilePosition declaredAt;
  }

  /**
   * @param nameGenerator an infinite iterator that returns safe identifiers
   *    that do not match any identifier used in javascript expressions attached
   *    to IHTML nodes, and that never returns the same String twice.
   */
  NameContext(Iterator&lt;String&gt; nameGenerator) {
    this.nameGenerator = nameGenerator;
  }

  NameContext subScope() {
    NameContext subScope = new NameContext(this);
    subScope.parent = this;
    return subScope;
  }

  void declare(String originalName, FilePosition declarationSite) {
    if (vars.contains(originalName)) { throw &hellip; }
    vars.put(originalName, new VarInfo(nameGenerator.next(), declarationSite));
  }

  private VarInfo lookup(String originalName) {
    for (NameContext c = this; c != null; c = c.parent) {
      VarInfo vi = c.vars.get(originalName);
      if (vi != null) { return vi; }
    }
    return null;
  }
}</pre>

<p>We create a pair of blank <code>NameContext</code>s, one for the
template namespace, and one for the namespace of variables, and recursively
walk the DOM.

<p>We invoke <code>NameContext.subScope()</code> to create a new scope for each
<code>ihtml:template</code> and <code>ihtml:do</code> element we reach.
For the former, we <code>declare()</code> the template name in the super-scope,
and the <code>formals</code> in the sub-scope.  For the latter, we declare the
<code>vars</code> in the sub-scope.

<p>After attaching the appropriate scope to a node, we check all its javascript
expressions and rename their free variables using the alpha renaming.  If the
<code>lookup</code> method returns null then one of the expressions has a
free variables, add it to the import set.

<p>After this step completes, we know that the javascript expressions are
encapsulated into their appropriate scopes.

<h4>Inferring Template Context</h4>
<p>To be able to rewrite <code>ihtml:attribute</code> expressions, we need
to know the element type that each attribute appears in.  For example, in</p>
<pre class="prettyprint">
&lt;ihtml:template name="type" formals="t"&gt;
  &lt;ihtml:attribute name="type"&gt;
    &lt;ihtml:dynamic expr="t"/&gt;
  &lt;/ihtml:attribute&gt;
&lt;/ihtml:template&gt;
&lt;input&gt;&lt;ihtml:call ihtml:template="type" t=" 'text' "/>&lt;/input&gt;
&lt;ul&gt;&lt;ihtml:call ihtml:template="type" t=" 'square' "/>&lt;/ul&gt;
</pre>
the dynamic attribute is used in both <code>input</code> and <code>ul</code>
elements which have very different meanings for the <code>type</code> attribute.
We walk the template call graph first to propagate the name of the HTML element
that a template is reachable from.  If a template is reachable from multiple,
then we copy it, as below:
<pre class="prettyprint">
&lt;ihtml:template name="type" formals="t" callingContext="input"&gt;
  &lt;ihtml:attribute name="type"&gt;
    &lt;ihtml:dynamic expr="t"/&gt;
  &lt;/ihtml:attribute&gt;
&lt;/ihtml:template&gt;
&lt;ihtml:template name="type" formals="t" callingContext="ul"&gt;
  &lt;ihtml:attribute name="type"&gt;
    &lt;ihtml:dynamic expr="t"/&gt;
  &lt;/ihtml:attribute&gt;
&lt;/ihtml:template&gt;
</pre>
When we later link calls to templates, we take into account the calling context.
<p>This scheme works because templates are not first-class, and allows us to
preserve Tenant's correspondance principle.

<h4>Sandboxing JS Expressions</h4>
<p>The cajoler is detailed elsewhere, and so will not be described here.
<p>This design relies on the cajoler to effectively sandbox malicious code,
and requires the cajoler to allow it to introduce safe identifiers into scope.
<p>Every javascript expression must contain only free variables that
are a formal template parameter declared in an enclosing
<code>ihtml:template</code> or a variable declared in an enclosing
<code>ihtml:do</code>'s <code>vars</code> attribute, or an extern supplied
by the template translator to allow calling out into cajoled template language
support code.  If a template language does not contain explicit var
declarations, the template translator should examine user supplied javascript
to find the set of free variables and add declarations at the appropriate level.

<h3>IHTML &rarr; JS Compiler</h3>
<p>The IHTML&rarr;JS compiler produces a javascript function.  It accepts a set
of IHTML parse trees and applies the transform described below to produce an
object with methods named after the template which can be loaded into
the local scope using the usual javascript mixin operation.
The names of the top level templates must be distinct.

<h4>Compilation</h4>
<p>Fist, the compiler creates empty functions for all top-level templates
and all re-entrant inner templates.  The function signatures look like
<code class="prettyprint">function <i>&lt;alphaName&gt;</i>(<i>&lt;outputBuffer0&gt;</i>, &hellip; <i>&lt;formal0&gt;</i>, &hellip;) { var <i>temporary0___</i>, &hellip;; &hellip; }</code>.
The output buffers are arrays that will accumulate chunks of HTML that
will be joined together later.  They may include one template for
textual content/markup, one for element names, and/or one for HTML
attributes.  The latter 2 are only appended to
by <code>ihtml:element</code> and <code>ihtml:attribute</code>
elements in the template body that are not contained in an HTML
element.  Templates that are called from within <code>ihtml:element</code>
to produce textual content put it onto the markup/text buffer.

<p>Second, the compiler recursively applies the algorithm described below to
turn the bodies of the templates for which we generated signatures into
function bodies.

<p>Finally, we create an envelope for the compilation unit which guarantees
that templates have a reliable path to call one another, and which produces
functions that can be loaded into the scope where the templates are needed.

<h4 id=contentFlavors>Content Flavors</h4>
<p>The set of buffers that must be passed to a function compiled from a
template depends on the types of content it can produce.  Each buffer
corresponds to a content flavor:
<ul>
<li>Text/Markup &mdash; produced by any template that contains an HTML
  element, or text node or <code>ihtml:dynamic</code> element outside a
  <code>ihtml:attribute</code> or <code>ihtml:element</code> element.
  <pre class="prettyprint">
    &lt;ihtml:template &hellip;&gt;  &lt;!-- has text flavor --&gt;
      Hello, World!
    &lt;/ihtml:template&gt;
    &lt;ihtml:template &hellip;&gt;  &lt;!-- no text flavor --&gt;
      &lt;ihtml:attribute &hellip;&gt;Hello, World!&lt;/ihtml:attribute&gt;
    &lt;/ihtml:template&gt;</pre>
<li>Attributes &mdash; produced by any template that contains an
  <code>ihtml:attribute</code> element that is not contained in an
  HTML element in the same template.
  <pre class="prettyprint">
    &lt;ihtml:template &hellip;&gt;  &lt;!-- has attribute flavor --&gt;
      &lt;ihtml:attribute &hellip;&gt;
    &lt;/ihtml:template&gt;
    &lt;ihtml:template &hellip;&gt;  &lt;!-- no attribute flavor --&gt;
      &lt;p&gt;
        &lt;ihtml:attribute &hellip;&gt;
      &lt;/p&gt;
    &lt;/ihtml:template&gt;</pre>
<li>Element Names &mdash; produced by any template that contains an
  <code>ihtml:element</code> element that is not contained in an
  HTML element in the same template.
  <pre class="prettyprint">
    &lt;ihtml:template &hellip;&gt;  &lt;!-- has element name flavor --&gt;
      &lt;ihtml:element&gt;
    &lt;/ihtml:template&gt;
    &lt;ihtml:template &hellip;&gt;  &lt;!-- no element name flavor --&gt;
      &lt;div&gt;
        &lt;ihtml:element&gt;
      &lt;/div&gt;
    &lt;/ihtml:template&gt;</pre>
</ul>
<h4>Recursive transform</h4>
<p>The transforms below take IHTML nodes and translate them into javascript.
They use javascript quasiliterals which are detailed elsewhere.

<p>When an <code>ihtml:template</code> is seen, skip it without recursing.</p>

<p>When an <code>ihtml:call</code> is seen, look up the corresponding
<code>ihtml:template</code> element using the alpha name of its
<code>ihtml:template</code> attribute and the tag context.
If it is a non-reentrant inner template that does not introduce local variables,
inline its body as in
<pre class="prettyprint">
// Below a4, a5 are formal parameters, and (3, "hello") are actual parameters.
var a4, a5;  // Added to enclosing function as temporaries.
&hellip;
(a4 = 3, a5 = hello, &lt;body&gt;)
</pre>
This inlining is valid because the alpha-renaming done earlier makes namespace
collision impossible, and because inner templates don't return a value or
transfer control non-locally.
<p>
Otherwise, if the call is to a top-level or reentrant template, then expand as
in
<pre class="prettyprint">
// t is the template's alpha name, and (3, "hello") are the actual parameters.
// We pass o___ so the called template uses the same output buffer.
// We may pass more, fewer, or different buffer parameters depending on the
// <a href="#contentFlavors">content flavors</a> produced.
t(o___, 3, "hello");
</pre>

<p>When we see an <code>ihtml:dynamic</code> element, we put the
<code>expr</code> onto the current output buffer, wrapping it in a call
that converts its result to a string and encodes HTML special characters
to HTML entities.

<p>When we see an <code>ihtml:do</code> element we do the following:
<ol>
<li>Add its alpha-renamed variable names to the list of local variables
  for the current template</code>.
<li>Produce a form of the below with semantics preserving optimizations:
<pre class="prettyprint">
  if (@init) {
    do {
      @thenClause*;
    } while (@whileCond);
  } else {
    @elseClause*;
  }
</pre>
</ol>

When we see a non-<code>ihtml</code> element e, do the following:
<ol>
<li>Push "<" onto the output/markup buffer
<li>If the body contains the element name content flavor, create a temporary
    variable, and emit an assignment that initializes it to the empty list.
    Push a reference to that temporary onto the output/markup buffer.
<li>Find <code>ihtml:attribute</code>s that are always executed 
    (not inside a <code>ihtml:do</code>), and that
    have inlinable bodies, and special case them here.
<li>If the body without those special cased attributes have the attributes
    content flavor, create a temporary variable and emit an assignment that
    initializes it to the empty list, and push a reference to that temporary
    onto the output/markup buffer.
<li>If the named element does not allow content, and the body does not have
    the text/markup content flavor, push " />" onto the output/markup buffer,
    and exit.
<li>Push ">" onto the output/markup buffer.
<li>Recurse to children passing the appropriate temporary buffers for
    the attribute and element name content flavors.
<li>Push "</" onto the output/markup buffer.
<li>If we created a temporary for the element name, emit a call to a function
    that consolidates content on the element name buffer, and that checks that
    it is safe to substitute for the original element name, and push a reference
    to the element name buffer onto the text/markup buffer; else push the
    element name onto the text/markup buffer.
<li>If we create a temporary for dynamic attributes, emit a call to a function
    that sanitizes them.
<li>Push ">" onto the output/markup buffer.
</ol>

<p>When we see a text node, push the content onto the appropriate output
buffer, after HTML escaping it.


<h4>Compilation Unit Envelope</h4>
If the compilation unit contained one top-level template named foo, the envelope
would look like
<pre class="prettyprint">
(function (T___, <i>&lt;externs_specified_by_template_translator&gt;</i>) {
  // a is the <a href="#alpha-renaming">&alpha;-name</a> for the template foo, and b is the &alpha;-name of
  // its only formal paramater.
  function <b>a</b>(<i>&lt;outputBuffers&gt;</i>, b) { &hellip; }

  return {
    // It would be nice if foo could show up as the name of the function so
    // that it would show in stacktraces, but then the name would be in scope
    // in the function below, which might mask names produced by the
    // alpha-renamer.
    <b>foo</b>: function (p0___) {
      var o___ = [];
      a0(o___, p0___);
      return T___.tm(o___);  // Joins and trademarks HTML
    }
  };
})
</pre>

<h3>Dynamic Sanitizes</h3>
<p>The code generated above defines several sanitizer and escaping methods.
<dl>
<dt><code>T___.e</code>
<dd>Given an output buffer containg a dynamic tag name, and a known good tag name
    returns the first if it can appear wherever the known good one can without
    extra required attributes, and otherwise errors out or returns the known
    good one.  Makes sure the output buffer always has length 1 afterwards
    by joining content.
<dt><code>T___.a</code>
<dd>Takes an output buffer with dynamic HTML attributes where some attribute
    values are preceded by type hints, and rewrites those attribute
    values using the type hints.
    Makes sure the output buffer always has length 1 afterwards
    by removing type hints and joining content.
<dt><code>T___.h</code>
<dd>Remove characters not allowed in XML (such as NUL U+0, and BOM U+FEFF) and
    rewrite all HTML special characters to entities including those
    special in attribute values.
<dt><code>T___.tm</code>
<dd>Takes an output buffer and joins it on the empty string to produce a string
    of known safe HTML.  Trademarks that HTML so that other parts of the system
    can verify that it is safe.
</dl>

<h2>Possible Extensions</h2>
<h3>Scoped style rules via <code>&lt;STYLE&gt;</code> elements in templates</h3>
If a <code>STYLE</code> element appears in a script block, we could
apply the CSS schemas at a stylesheet level, and scope all rules by
generating a GUID and using it both in a class at the top of the template
output, and prefixing style rules.  E.g., if the GUID were 1234, then
we would add a <code>&lt;div class="s1234"&gt;</code> around the
template body (or SPAN if the template does not contribute block level
children), and convert each style rule by prefixing with the GUID as in
<code class="prettyprint lang-css">p { color: purple }</code> &rarr;
<code class="prettyprint lang-css">.s1234 p { color: purple }</code>.

<h3>CSS templates via expressions embedded in
<code>style="&hellip;"</code> attributes</h3>
Our static CSS schemas are much more flexible than the client side ones, and
have facilities to require constraints on placeholders as in
<pre class="prettyprint"
>&lt;div style="width: $(w)px; height: $(h + 10)px"&gt;
  &hellip;
&lt;/div&gt;
</pre>
We can expose these so that template compiler implementors can allow
template parameters to be used to compute positions and URLs flexibly
and without the possibility of quoting confusion.

<h3>DHTML Behaviors via <code>&lt;SCRIPT&gt;</code> elements in templates</h3>
<p>We could emulate DHTML behaviors as in
<pre class="prettyprint">
&lt;!-- blink using javascript, because we can --&gt;
&lt;span class="blinky"&gt;$i_blink&lt;/span&gt;
&lt;script&gt;
  // Properly scoped virtual document that only affects the template
  // generated sub-tree.
  document.getElementsByClassName('blinky').style.textDecoration = 'blink';
&lt;/script&gt;
</pre>
where the script is pulled out and stored as a promise that is realized
when the HTML is added to the real DOM.
<p>Though this example isn't useful, behaviors can be used to wire up
widgets that contain a Google Maps or other gadget that can't be generated
by a callable template.

<h3 id="gadgets-zero-arg">Gadgets as Zero-Argument Templates</h3>
<p>Similar to DHTML behaviors, an opensocial gadget is an HTML page with
interleaved script elements.  To improve latency, we'd like to be able
to render CSS and HTML before downloading, parsing, or running scripts
<p>If we treat a gadget as a zero-argument template, we can convert a
gadget like:
<pre class="prettyprint">
&lt;h1&gt;My Gadget&lt;/h1&gt;
&lt;script&gt;
  foo();
&lt;/script&gt;
&lt;a onclick="hello()"&gt;Hello&lt;/a&gt;
</pre>
into a static HTML part and a script part
<table>
<tr>
<td><pre class="prettyprint">
&lt;noscript&gt;
  &lt;!-- With script off, works as expected.
    -  (CAVEAT: noscript content not manipulable by JS on IE)
   --&gt;
  &lt;h1&gt;My Gadget&lt;/h1&gt;
  &lt;!-- Each node opened between the n-th and (n+1)-th script elements
    -  that is not contained in an element also opened between the n-th and
    -  (n+1)-th script elements has the class afterScript&lt;n&gt;___.
   --&gt;
  &lt;a class="tmp0123___ afterScript0___"&gt;Hello&lt;/a&gt;
&lt;/noscript&gt;
</pre>
<td><pre class="prettyprint">
// Script elements are cajoled to functions
var scripts = [ function () { /* Cajoled version of foo() */ } ];
// A side-table of dynamic attributes which can evaluate dynamic bits
// in the context of this instance of the module.
var dynamicBits = [ ['tmp0123___', 'onclick', /* extracted handler */ ] ];

var moduleRoot = document.createElement('DIV');
// Non-dynamic bits of gadget parsed at HTML parser speed.
// No IE6 confusion around document.appendChild(whitespaceTextNode)
moduleRoot.innerHTML = noScriptElement.innerText;

// Reattach dynamicBits to moduleRoot.
&hellip;

// Pull out everything with class afterScript#___, so that each script
// is executed in the context of only elements that appear before it.
var extractedNodes = [];
for (var i = 0; i &lt;= scripts.length; ++i) {
  // getElementsByTagName is required to produce results in a preorder
  // traversal.
  var els = moduleRoot.getElementsByTagName('afterScript' + i + '___');
  var wave = extractedNodes[i] = [];
  for (var j = els.length; --j &gt;= 0;) {
    // TODO: If the node was a text node wrapped in a span solely so that it
    // could be marked with a wave class, throw away the span.
    wave[j] = [els[j], els[j].parentNode];
    removeClass(els[j], 'afterScript' + i + '___');
  }
}

for (var i = 0; i &lt;= scripts.length; ++i) {
  try {  // Execute script0
    scripts[i]();
  } catch (e) {
    // Simulate window.onerror
  }

  // Put back removed bits.
  var wave = extractedNodes[i];
  for (var j = 0; j &lt; wave.length; ++j) {
    wave[j][1].appendChild(wave[j][0]);
  }
}
</pre>
</table>

<p>This HTML generation needs to happen after any text-localization and
any automatic LTR&rarr;RTL restyling.</p>

<h3 id="auto-rtl">Automatic Bidi support</h3>
<p>Since we have to parse style properties and stylesheets so that we
can apply schemas, it would be quite easy to rewrite style properties
(<code>padding-left</code>, <code>margin-left</code>), style values
(<code>text-align: left</code>) and the HTML
<a href="http://www.w3.org/TR/html401/struct/dirlang.html"><code>DIR</code>
attribute</a> when the input locale is for an RTL language.</p>


<h2>Assumptions and Invariants</h2>
<p>For each of the elements that can contain dynamic tag names
(DIV, SPAN, TBODY, TR), we can identify which tag names can safely
go there by comparing allowed attributes and attribute criteria.
E.g., we can say that a DIV element can be turned into a P element
by a <code>&lt;ihtml:element&gt;&lt;ihtml:dynamic expr="'P'"/&gt;&lt;/ihtml:element&gt;</code> safely since
attributes allowed on DIV always have the same meaning on P.

<p>If an HTML element that a template can produce can contain one of any
other type of element then it can contain any number, or security
policies don't rely on this not being true.  Our schemas don't
whitelist HTML or HEAD so this should hold.  This is why the "union"
clause under IHTML holds in the presence of <code>ihtml:do</code>
alternates and initially false conditions.

<p>Dynamically attributes are not represented as placeholders in
the output.  Specifically, when compiling <code>&lt;a href="$foo"&gt;</code>
the IHTML tree does not contain a blank href attribute since then we
would be relying on a blank href to be replaced which might violate
our security policy.  We are secure against intermediate invalid forms
of the template escaping because we never transition through an invalid
state.

<p>An HTML schema must not rely on preserving the relationship between
two or more attributes for security properties.  E.g., if a security
policy might be violated by an <code>&lt;A&gt;</code> element without
an appropriate <code>target</code> attribute, then it must mandate one
regardless of whether there is an <code>href</code> attribute.
If this holds, then it is safe for a dynamic attribute of the same name
to trump a statically specified one.

<p>A template output is only injected into a node that accepts PCDATA
content and can contain arbitrary block or inline elements.
A template might produce output that contains a single text node which is a
valid javascript string, and which should not be injected into a
<code>&lt;script&gt;</code> element.
The HTML schemas contain a whitelist of elements that are safe this way.

<p>if resolving dynamic bits requires looking up DOM nodes in a tree,
it is done in a way that is properly scoped, and done until no more
matches are found.  Even if a string of HTML contains only one tag
with a given ID, due to the adoption agency algorithm, the parsed
DOM might contain multiple elements with that ID, as in
<code class="prettyprint"
>&lt;b&gt;&lt;i id="x"&gt;foo&lt;/b&gt;bar&lt;/i&gt;</code>

<p>When multiple templates appear in the same compilation unit and
call one another, malicious code cannot mask or replace a template
function.  Templates within a compilation unit must share some
scope that is not manipulable by malicious code.  If this does not
hold, then an attacker could use a man-in-the-middle to return
invalid HTML which would cause the caller to improperly trademark
an invalid output.

<h2>Work Estimates</h2>
<p>Defining schemas and doing schema validation is already done, as are
facilities for parsing JS/CSS/HTML and manipulating parse trees.
<p>Client side schemas are already done, as are versions of the
client side sanitization methods.
<p>The bulk of the work would be in implementing the IHTML&rarr;JS compiler
which is specified as a fairly simple transform.  Took several weeks.
<p>Before this can be tested though, we would need to implement a
template compiler.  Perhaps something with simple perl style "$string"
interpolation anywhere with if &amp; foreach tags using javascript as the
expression language.  Implemented on top of the
existing DOM parser.
<p>Porting a more serious templating language like OSML or YML would
take longer the first time through since significant debugging of the
IHTML&rarr;JS compiler can only happen in parallel.
</body>
</html>
